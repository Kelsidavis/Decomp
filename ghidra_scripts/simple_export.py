# ghidra_scripts/simple_export.py
# Runs inside Ghidra headless. Exports:
#  - JSON summary of functions (start, end, name, prototype, pseudo, etc.)
#  - One C file per function into OUT_SRC_DIR (if set)
#
# Env used (string values):
#   BINARY_PATH      : input program path (provided by analyzeHeadless wrapper)
#   OUT_JSON         : absolute output json path (e.g., /work/snapshots/foo_out.json)
#   OUT_SRC_DIR      : absolute dir for per-function C files (e.g., /work/recovered_project/src)
#   EXPORT_TOPN      : max functions to export (default: all)
#   DECOMPILE_SEC    : decompile timeout per function (seconds, default 12)
#   SKIP_PSEUDO      : "1" to skip decompile text (metadata-only)
#
# Notes:
#  - Writes safe filenames as: <sanitized_name>_<addr>.c (addr = 0x... start EA)
#  - If two functions share a name, address keeps files unique.
#  - JSON shape is stable and friendly to your current pipeline.

from __future__ import print_function
import os, re, json, time

from ghidra.app.decompiler import DecompInterface
from ghidra.util.task import ConsoleTaskMonitor
from ghidra.program.flatapi import FlatProgramAPI

# ---------- helpers ----------
def _getenv(k, d=None):
    v = os.getenv(k)
    return v if v is not None and v != "" else d

def _to_int(x):
    if x is None: return None
    if isinstance(x, (int, long)): return int(x)
    s = str(x).strip().lower()
    try:
        return int(s, 16) if s.startswith("0x") else int(s, 10)
    except Exception:
        return None

def _hex(ea):
    return "0x%X" % (int(ea),)

def _san(s):
    if not s:
        return "func"
    s = re.sub(r'[^0-9A-Za-z_]+', '_', s)
    s = s.strip('_')
    return s or "func"

def _proto_for(fn):
    try:
        # getPrototypeString(showCallingConvention, includeReturnStorage)
        return fn.getPrototypeString(True, True)
    except Exception:
        return "void %s(void)" % (fn.getName(),)

def _ensure_dir(p):
    if not p: return
    if not os.path.isdir(p):
        os.makedirs(p)

# ---------- config ----------
BINARY_PATH   = _getenv("BINARY_PATH")
OUT_JSON      = _getenv("OUT_JSON", "/work/snapshots/out.json")
OUT_SRC_DIR   = _getenv("OUT_SRC_DIR")  # optional
EXPORT_TOPN   = _to_int(_getenv("EXPORT_TOPN"))
DECOMPILE_SEC = _to_int(_getenv("DECOMPILE_SEC")) or 12
SKIP_PSEUDO   = _getenv("SKIP_PSEUDO", "0") == "1"

monitor = ConsoleTaskMonitor()
prog     = currentProgram
if prog is None:
    # When running in headless, Ghidra will open the program before this script runs.
    raise RuntimeError("No program is open in Ghidra script context")

fm       = prog.getFunctionManager()
api      = FlatProgramAPI(prog)

iface = DecompInterface()
iface.openProgram(prog)
# Tweak options if you like:
# iface.setSimplificationStyle("decompile")

funcs_iter = fm.getFunctions(True)
functions = []
for f in funcs_iter:
    try:
        start = int(f.getEntryPoint().getOffset())
        end   = int(f.getBody().getMaxAddress().getOffset())
        functions.append((start, end, f))
    except Exception:
        pass

# Sort by entry EA to keep stable order
functions.sort(key=lambda t: t[0])
if EXPORT_TOPN and EXPORT_TOPN > 0:
    functions = functions[:EXPORT_TOPN]

# Prepare output
items = []
if OUT_SRC_DIR:
    _ensure_dir(OUT_SRC_DIR)

def _write_c_file(name, addr, proto, pseudo):
    if not OUT_SRC_DIR:
        return
    base = "%s_%s.c" % (_san(name), _hex(addr))
    path = os.path.join(OUT_SRC_DIR, base)
    with open(path, "w") as w:
        w.write("/*\n")
        w.write(" * Function: %s\n" % name)
        w.write(" * Address : %s\n" % _hex(addr))
        w.write(" * Generated by Ghidra exporter\n")
        w.write(" */\n\n")
        if proto:
            w.write(proto)
            if not proto.strip().endswith("}"):
                w.write(" {\n")
        else:
            w.write("void %s(void) {\n" % _san(name))
        if pseudo:
            w.write("\n  /* Decompiled pseudocode */\n")
            for line in pseudo.splitlines():
                w.write("  // %s\n" % line)
        else:
            w.write("  /* no pseudocode available (timeout or disabled) */\n")
        w.write("\n}\n")
    return path

count = 0
t0 = time.time()
for (startEA, endEA, fn) in functions:
    name = fn.getName()
    proto = _proto_for(fn)
    pseudo = ""
    decomp_ok = False
    if not SKIP_PSEUDO:
        try:
            res = iface.decompileFunction(fn, DECOMPILE_SEC, monitor)
            if res and res.decompileCompleted():
                df = res.getDecompiledFunction()
                if df:
                    pseudo = df.getC()
                    decomp_ok = True
        except Exception:
            pass

    # write .c file
    c_path = _write_c_file(name, startEA, proto, pseudo)

    items.append({
        "start": startEA,
        "end": endEA,
        "name": name,
        "prototype": proto,
        "pseudo": pseudo,
        "decompiled": bool(pseudo),
        "source_path": c_path or ""
    })
    count += 1

# Emit JSON
_ensure_dir(os.path.dirname(OUT_JSON))
with open(OUT_JSON, "w") as f:
    json.dump({"functions": items}, f)

print("Exported %d functions to %s" % (count, OUT_JSON))
if OUT_SRC_DIR:
    print("Per-function C files in: %s" % OUT_SRC_DIR)

